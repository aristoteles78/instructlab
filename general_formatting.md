General Formatting
------------------

### Column Limit

Swift code has a column limit of 100 characters. Except as noted below, any line that would exceed this limit must be line-wrapped as described in [Line-Wrapping](https://google.github.io/swift/#line-wrapping).

**Exceptions:**

1.  Lines where obeying the column limit is not possible without breaking a meaningful unit of text that should not be broken (for example, a long URL in a comment).
2.  `import` statements.
3.  Code generated by another tool.

### Braces

In general, braces follow Kernighan and Ritchie (K&R) style for non-empty blocks with exceptions for Swift-specific constructs and rules:

-   There **is no** line break before the opening brace (`{`), **unless** required by application of the rules in [Line-Wrapping](https://google.github.io/swift/#line-wrapping).
-   There **is a** line break after the opening brace (`{`), except
    -   in closures, where the signature of the closure is placed on the same line as the curly brace, if it fits, and a line break follows the `in` keyword.
    -   where it may be omitted as described in [One Statement Per Line](https://google.github.io/swift/#one-statement-per-line).
    -   empty blocks may be written as `{}`.
-   There **is a** line break before the closing brace (`}`), except where it may be omitted as described in [One Statement Per Line](https://google.github.io/swift/#one-statement-per-line), or it completes an empty block.
-   There **is a** line break after the closing brace (`}`), **if and only if** that brace terminates a statement or the body of a declaration. For example, an `else` block is written `} else {` with both braces on the same line.

### Semicolons

Semicolons (`;`) are **not used**, either to terminate or separate statements.

In other words, the only location where a semicolon may appear is inside a string literal or a comment.

```
func printSum(_ a: Int, _ b: Int) {
  let sum = a + b
  print(sum)
}

```

```
func printSum(_ a: Int, _ b: Int) {
  let sum = a + b;
  print(sum);
}

```

### One Statement Per Line

There is **at most** one statement per line, and each statement is followed by a line break, except when the line ends with a block that also contains zero or one statements.

```
guard let value = value else { return 0 }

defer { file.close() }

switch someEnum {
case .first: return 5
case .second: return 10
case .third: return 20
}

let squares = numbers.map { $0 * $0 }

var someProperty: Int {
  get { return otherObject.property }
  set { otherObject.property = newValue }
}

var someProperty: Int { return otherObject.somethingElse() }

required init?(coder aDecoder: NSCoder) { fatalError("no coder") }

```

Wrapping the body of a single-statement block onto its own line is always allowed. Exercise best judgment when deciding whether to place a conditional statement and its body on the same line. For example, single line conditionals work well for early-return and basic cleanup tasks, but less so when the body contains a function call with significant logic. When in doubt, write it as a multi-line statement.

### Line-Wrapping

> Terminology note: **Line-wrapping** is the activity of dividing code into multiple lines that might otherwise legally occupy a single line.

For the purposes of Google Swift style, many declarations (such as type declarations and function declarations) and other expressions (like function calls) can be partitioned into **breakable** units that are separated by **unbreakable** delimiting token sequences.

As an example, consider the following complex function declaration, which needs to be line-wrapped:

```
public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) -> Elements.Index? where Elements.Element == Element, Element: Equatable {
  // ...
}

```

This declaration is split as follows (scroll horizontally if necessary to see the full example). Unbreakable token sequences are indicated in orange; breakable sequences are indicated in blue.

public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) ->Elements.Index?whereElements.Element == Element, Element: Equatable{
  // ...
}

1.  The **unbreakable** token sequence up through the open angle bracket (`<`) that begins the generic argument list.
2.  The **breakable** list of generic arguments.
3.  The **unbreakable** token sequence (`>(`) that separates the generic arguments from the formal arguments.
4.  The **breakable** comma-delimited list of formal arguments.
5.  The **unbreakable** token-sequence from the closing parenthesis (`)`) up through the arrow (`->`) that precedes the return type.
6.  The **breakable** return type.
7.  The **unbreakable** `where` keyword that begins the generic constraints list.
8.  The **breakable** comma-delimited list of generic constraints.

Using these concepts, the cardinal rules of Google Swift style for line-wrapping are:

1.  If the entire declaration, statement, or expression fits on one line, then do that.
2.  Comma-delimited lists are only laid out in one direction: horizontally or vertically. In other words, all elements must fit on the same line, or each element must be on its own line. A horizontally-oriented list does not contain any line breaks, even before the first element or after the last element. Except in control flow statements, a vertically-oriented list contains a line break before the first element and after each element.
3.  A continuation line starting with an unbreakable token sequence is indented at the same level as the original line.
4.  A continuation line that is part of a vertically-oriented comma-delimited list is indented exactly +2 from the original line.
5.  When an open curly brace (`{`) follows a line-wrapped declaration or expression, it is on the same line as the final continuation line unless that line is indented at +2 from the original line. In that case, the brace is placed on its own line, to avoid the continuation lines from blending visually with the body of the subsequent block.

    ```
    public func index<Elements: Collection, Element>(
      of element: Element,
      in collection: Elements
    ) -> Elements.Index?
    where
      Elements.Element == Element,
      Element: Equatable
    {  // GOOD.
      for current in elements {
        // ...
      }
    }

    ```

    ```
    public func index<Elements: Collection, Element>(
      of element: Element,
      in collection: Elements
    ) -> Elements.Index?
    where
      Elements.Element == Element,
      Element: Equatable {  // AVOID.
      for current in elements {
        // ...
      }
    }

    ```

For declarations that contain a `where` clause followed by generic constraints, additional rules apply:

1.  If the generic constraint list exceeds the column limit when placed on the same line as the return type, then a line break is first inserted **before** the `where` keyword and the `where` keyword is indented at the same level as the original line.
2.  If the generic constraint list still exceeds the column limit after inserting the line break above, then the constraint list is oriented vertically with a line break after the `where` keyword and a line break after the final constraint.

Concrete examples of this are shown in the relevant subsections below.

This line-wrapping style ensures that the different parts of a declaration are *quickly and easily identifiable to the reader* by using indentation and line breaks, while also preserving the same indentation level for those parts throughout the file. Specifically, it prevents the zig-zag effect that would be present if the arguments are indented based on opening parentheses, as is common in other languages:

```
public func index<Elements: Collection, Element>(of element: Element,  // AVOID.
                                                 in collection: Elements) -> Elements.Index?
    where Elements.Element == Element, Element: Equatable {
  doSomething()
}

```

#### Function Declarations

*modifiers* func *name*(*formal arguments*){

*modifiers* func *name*(*formal arguments*) ->*result*{

*modifiers* func *name*<*generic arguments*>(*formal arguments*) throws ->*result*{

*modifiers* func *name*<*generic arguments*>(*formal arguments*) throws ->*result*where*generic constraints*{

Applying the rules above from left to right gives us the following line-wrapping:

```
public func index<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> Elements.Index? where Elements.Element == Element, Element: Equatable {
  for current in elements {
    // ...
  }
}

```

Function declarations in protocols that are terminated with a closing parenthesis (`)`) may place the parenthesis on the same line as the final argument **or** on its own line.

```
public protocol ContrivedExampleDelegate {
  func contrivedExample(
    _ contrivedExample: ContrivedExample,
    willDoSomethingTo someValue: SomeValue)
}

public protocol ContrivedExampleDelegate {
  func contrivedExample(
    _ contrivedExample: ContrivedExample,
    willDoSomethingTo someValue: SomeValue
  )
}

```

If types are complex and/or deeply nested, individual elements in the arguments/constraints lists and/or the return type may also need to be wrapped. In these rare cases, the same line-wrapping rules apply to those parts as apply to the declaration itself.

```
public func performanceTrackingIndex<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> (
  Element.Index?,
  PerformanceTrackingIndexStatistics.Timings,
  PerformanceTrackingIndexStatistics.SpaceUsed
) {
  // ...
}

```

However, `typealias`es or some other means are often a better way to simplify complex declarations whenever possible.

#### Type and Extension Declarations

The examples below apply equally to `class`, `struct`, `enum`, `extension`, and `protocol` (with the obvious exception that all but the first do not have superclasses in their inheritance list, but they are otherwise structurally similar).

*modifiers* class *Name*{

*modifiers* class *Name*:*superclass and protocols*{

*modifiers* class *Name*<*generic arguments*>:*superclass and protocols*{

*modifiers* class *Name*<*generic arguments*>:*superclass and protocols*where*generic constraints*{

```
class MyClass:
  MySuperclass,
  MyProtocol,
  SomeoneElsesProtocol,
  SomeFrameworkProtocol
{
  // ...
}

class MyContainer<Element>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
{
  // ...
}

class MyContainer<BaseCollection>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
where BaseCollection: Collection {
  // ...
}

class MyContainer<BaseCollection>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
where
  BaseCollection: Collection,
  BaseCollection.Element: Equatable,
  BaseCollection.Element: SomeOtherProtocolOnlyUsedToForceLineWrapping
{
  // ...
}

```

#### Function Calls

When a function call is line-wrapped, each argument is written on its own line, indented +2 from the original line.

As with function declarations, if the function call terminates its enclosing statement and ends with a closing parenthesis (`)`) (that is, it has no trailing closure), then the parenthesis may be placed **either** on the same line as the final argument **or** on its own line.

```
let index = index(
  of: veryLongElementVariableName,
  in: aCollectionOfElementsThatAlsoHappensToHaveALongName)

let index = index(
  of: veryLongElementVariableName,
  in: aCollectionOfElementsThatAlsoHappensToHaveALongName
)

```

If the function call ends with a trailing closure and the closure's signature must be wrapped, then place it on its own line and wrap the argument list in parentheses to distinguish it from the body of the closure below it.

```
someAsynchronousAction.execute(withDelay: howManySeconds, context: actionContext) {
  (context, completion) in
  doSomething(withContext: context)
  completion()
}

```

#### Control Flow Statements

When a control flow statement (such as `if`, `guard`, `while`, or `for`) is wrapped, the first continuation line is indented to the same position as the token following the control flow keyword. Additional continuation lines are indented at that same position if they are syntactically parallel elements, or in +2 increments from that position if they are syntactically nested.

The open brace (`{`) preceding the body of the control flow statement can either be placed on the same line as the last continuation line or on the next line, at the same indentation level as the beginning of the statement. For `guard` statements, the `else {` must be kept together, either on the same line or on the next line.

```
if aBooleanValueReturnedByAVeryLongOptionalThing() &&
   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&
   yetAnotherBooleanValueThatContributesToTheWrapping() {
  doSomething()
}

if aBooleanValueReturnedByAVeryLongOptionalThing() &&
   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&
   yetAnotherBooleanValueThatContributesToTheWrapping()
{
  doSomething()
}

if let value = aValueReturnedByAVeryLongOptionalThing(),
   let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() {
  doSomething()
}

if let value = aValueReturnedByAVeryLongOptionalThing(),
   let value2 = aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped()
{
  doSomething()
}

guard let value = aValueReturnedByAVeryLongOptionalThing(),
      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() else {
  doSomething()
}

guard let value = aValueReturnedByAVeryLongOptionalThing(),
      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing()
else {
  doSomething()
}

for element in collection
    where element.happensToHaveAVeryLongPropertyNameThatYouNeedToCheck {
  doSomething()
}

```

#### Other Expressions

When line-wrapping other expressions that are not function calls (as described above), the second line (the one immediately following the first break) is indented exactly +2 from the original line.

When there are multiple continuation lines, indentation may be varied in increments of +2 as needed. In general, two continuation lines use the same indentation level if and only if they begin with syntactically parallel elements. However, if there are many continuation lines caused by long wrapped expressions, consider splitting them into multiple statements using temporary variables when possible.

```
let result = anExpression + thatIsMadeUpOf * aLargeNumber +
  ofTerms / andTherefore % mustBeWrapped + (
    andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)

```

```
let result = anExpression + thatIsMadeUpOf * aLargeNumber +
    ofTerms / andTherefore % mustBeWrapped + (
        andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)

```

### Horizontal Whitespace

> **Terminology note:** In this section, *horizontal whitespace* refers to *interior* space. These rules are never interpreted as requiring or forbidding additional space at the start of a line.

Beyond where required by the language or other style rules, and apart from literals and comments, a single Unicode space also appears in the following places **only**:

1.  Separating any reserved word starting a conditional or switch statement (such as `if`, `guard`, `while`, or `switch`) from the expression that follows it if that expression starts with an open parenthesis (`(`).

    ```
    if (x == 0 && y == 0) || z == 0 {
      // ...
    }

    ```

    ```
    if(x == 0 && y == 0) || z == 0 {
      // ...
    }

    ```

2.  Before any closing curly brace (`}`) that follows code on the same line, before any open curly brace (`{`), and after any open curly brace (`{`) that is followed by code on the same line.

    ```
    let nonNegativeCubes = numbers.map { $0 * $0 * $0 }.filter { $0 >= 0 }

    ```

    ```
    let nonNegativeCubes = numbers.map { $0 * $0 * $0 } .filter { $0 >= 0 }
    let nonNegativeCubes = numbers.map{$0 * $0 * $0}.filter{$0 >= 0}

    ```

3.  *On both sides* of any binary or ternary operator, including the "operator-like" symbols described below, with exceptions noted at the end:

    1.  The `=` sign used in assignment, initialization of variables/properties, and default arguments in functions.

        ```
        var x = 5

        func sum(_ numbers: [Int], initialValue: Int = 0) {
          // ...
        }

        ```

        ```
        var x=5

        func sum(_ numbers: [Int], initialValue: Int=0) {
          // ...
        }

        ```

    2.  The ampersand (`&`) in a protocol composition type.

        ```
        func sayHappyBirthday(to person: NameProviding & AgeProviding) {
          // ...
        }

        ```

        ```
        func sayHappyBirthday(to person: NameProviding&AgeProviding) {
          // ...
        }

        ```

    3.  The operator symbol in a function declaring/implementing that operator.

        ```
        static func == (lhs: MyType, rhs: MyType) -> Bool {
          // ...
        }

        ```

        ```
        static func ==(lhs: MyType, rhs: MyType) -> Bool {
          // ...
        }

        ```

    4.  The arrow (`->`) preceding the return type of a function.

        ```
        func sum(_ numbers: [Int]) -> Int {
          // ...
        }

        ```

        ```
        func sum(_ numbers: [Int])->Int {
          // ...
        }

        ```

    5.  **Exception:** There is no space on either side of the dot (`.`) used to reference value and type members.

        ```
        let width = view.bounds.width

        ```

        ```
        let width = view . bounds . width

        ```

    6.  **Exception:** There is no space on either side of the `..<` or `...` operators used in range expressions.

        ```
        for number in 1...5 {
          // ...
        }

        let substring = string[index..<string.endIndex]

        ```

        ```
        for number in 1 ... 5 {
          // ...
        }

        let substring = string[index ..< string.endIndex]

        ```

4.  After, but not before, the comma (`,`) in parameter lists and in tuple/array/dictionary literals.

    ```
    let numbers = [1, 2, 3]

    ```

    ```
    let numbers = [1,2,3]
    let numbers = [1 ,2 ,3]
    let numbers = [1 , 2 , 3]

    ```

5.  After, but not before, the colon (`:`) in

    1.  Superclass/protocol conformance lists and generic constraints.

        ```
        struct HashTable: Collection {
          // ...
        }

        struct AnyEquatable<Wrapped: Equatable>: Equatable {
          // ...
        }

        ```

        ```
        struct HashTable : Collection {
          // ...
        }

        struct AnyEquatable<Wrapped : Equatable> : Equatable {
          // ...
        }

        ```

    2.  Function argument labels and tuple element labels.

        ```
        let tuple: (x: Int, y: Int)

        func sum(_ numbers: [Int]) {
          // ...
        }

        ```

        ```
        let tuple: (x:Int, y:Int)
        let tuple: (x : Int, y : Int)

        func sum(_ numbers:[Int]) {
          // ...
        }

        func sum(_ numbers : [Int]) {
          // ...
        }

        ```

    3.  Variable/property declarations with explicit types.

        ```
        let number: Int = 5

        ```

        ```
        let number:Int = 5
        let number : Int = 5

        ```

    4.  Shorthand dictionary type names.

        ```
        var nameAgeMap: [String: Int] = []

        ```

        ```
        var nameAgeMap: [String:Int] = []
        var nameAgeMap: [String : Int] = []

        ```

    5.  Dictionary literals.

        ```
        let nameAgeMap = ["Ed": 40, "Timmy": 9]

        ```

        ```
        let nameAgeMap = ["Ed":40, "Timmy":9]
        let nameAgeMap = ["Ed" : 40, "Timmy" : 9]

        ```

6.  At least two spaces before and exactly one space after the double slash (`//`) that begins an end-of-line comment.

    ```
    let initialFactor = 2  // Warm up the modulator.

    ```

    ```
    let initialFactor = 2 //    Warm up the modulator.

    ```

7.  Outside, but not inside, the brackets of an array or dictionary literals and the parentheses of a tuple literal.

    ```
    let numbers = [1, 2, 3]

    ```

    ```
    let numbers = [ 1, 2, 3 ]

    ```

### Horizontal Alignment

> **Terminology note:** *Horizontal alignment* is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.

Horizontal alignment is forbidden except when writing obviously tabular data where omitting the alignment would be harmful to readability. In other cases (for example, lining up the types of stored property declarations in a `struct` or `class`), horizontal alignment is an invitation for maintenance problems if a new member is introduced that requires every other member to be realigned.

```
struct DataPoint {
  var value: Int
  var primaryColor: UIColor
}

```

```
struct DataPoint {
  var value:        Int
  var primaryColor: UIColor
}

```

### Vertical Whitespace

A single blank line appears in the following locations:

1.  Between consecutive members of a type: properties, initializers, methods, enum cases, and nested types, **except that**:

    1.  A blank line is optional between two consecutive stored properties or two enum cases whose declarations fit entirely on a single line. Such blank lines can be used to create *logical groupings* of these declarations.
    2.  A blank line is optional between two extremely closely related properties that do not otherwise meet the criterion above; for example, a private stored property and a related public computed property.
2.  *Only as needed* between statements to organize code into logical subsections.
3.  *Optionally* before the first member or after the last member of a type (neither is encouraged nor discouraged).
4.  Anywhere explicitly required by other sections of this document.

*Multiple* blank lines are permitted, but never required (nor encouraged). If you do use multiple consecutive blank lines, do so consistently throughout your code base.

### Parentheses

Parentheses are **not** used around the top-most expression that follows an `if`, `guard`, `while`, or `switch` keyword.

```
if x == 0 {
  print("x is zero")
}

if (x == 0 || y == 1) && z == 2 {
  print("...")
}

```

```
if (x == 0) {
  print("x is zero")
}

if ((x == 0 || y == 1) && z == 2) {
  print("...")
}

```

Optional grouping parentheses are omitted only when the author and the reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor that they would have made the code easier to read. It is *not* reasonable to assume that every reader has the entire Swift operator precedence table memorized.
